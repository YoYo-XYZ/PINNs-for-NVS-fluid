# ==================== 2D Steady Channel Flow with DeepXDE ====================
# Requirements:
# pip install deepxde matplotlib numpy scipy

import deepxde as dde
import numpy as np
import torch
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable

# -------------------------- Parameters --------------------------
Re = 100          # Reynolds number (keep low for steady laminar flow, e.g., Re < 200)
nu = 1.0 / Re     # Kinematic viscosity
dpdx = -2.0       # Pressure gradient (negative = flow in +x direction)
H = 1.0           # Channel height (y from 0 to 1)
L = 4.0           # Channel length (x from 0 to 4, long enough to neglect inlet effects)

# Analytical solution for fully developed Poiseuille flow: u(y) = -dpdx/(2*nu) * y*(H-y)
u_analytical = lambda y: -dpdx / (2 * nu) * y * (H - y)

# -------------------------- Geometry and Time --------------------------
geom = dde.geometry.Rectangle([0, 0], [L, H])

# -------------------------- PDE: Steady Navier-Stokes --------------------------
def pde(x, uvp):
    u, v, p = uvp[:, 0:1], uvp[:, 1:2], uvp[:, 2:3]
    
    # First derivatives
    du_dx = dde.grad.jacobian(uvp, x, i=0, j=0)
    du_dy = dde.grad.jacobian(uvp, x, i=0, j=1)
    dv_dx = dde.grad.jacobian(uvp, x, i=1, j=0)
    dv_dy = dde.grad.jacobian(uvp, x, i=1, j=1)
    dp_dx = dde.grad.jacobian(uvp, x, i=2, j=0)
    dp_dy = dde.grad.jacobian(uvp, x, i=2, j=1)

    # Second derivatives (Hessian)
    du_dxx = dde.grad.hessian(uvp, x, component=0, i=0, j=0)
    du_dyy = dde.grad.hessian(uvp, x, component=0, i=1, j=1)
    dv_dxx = dde.grad.hessian(uvp, x, component=1, i=0, j=0)
    dv_dyy = dde.grad.hessian(uvp, x, component=1, i=1, j=1)
    
    # Continuity equation
    continuity = du_dx + dv_dy
    
    # Momentum equations
    momentum_x = u * du_dx + v * du_dy + dp_dx - nu * (du_dxx + du_dyy)
    momentum_y = u * dv_dx + v * dv_dy + dp_dy - nu * (dv_dxx + dv_dyy)
    
    return [continuity, momentum_x, momentum_y]

# -------------------------- Boundary Conditions --------------------------
def boundary_bottom(x, on_boundary):
    return on_boundary and np.isclose(x[1], 0)

def boundary_top(x, on_boundary):
    return on_boundary and np.isclose(x[1], H)

def boundary_inlet(x, on_boundary):
    return on_boundary and np.isclose(x[0], 0)

def boundary_outlet(x, on_boundary):
    return on_boundary and np.isclose(x[0], L)

# No-slip on walls
bc_u_bottom = dde.icbc.DirichletBC(geom, lambda x: 0.0, boundary_bottom, component=0)
bc_v_bottom = dde.icbc.DirichletBC(geom, lambda x: 0.0, boundary_bottom, component=1)
bc_u_top    = dde.icbc.DirichletBC(geom, lambda x: 0.0, boundary_top,    component=0)
bc_v_top    = dde.icbc.DirichletBC(geom, lambda x: 0.0, boundary_top,    component=1)

# Periodic BCs on inlet/outlet for u and v (fully developed assumption)
bc_u_periodic = dde.icbc.PeriodicBC(geom, 0, boundary_inlet, component=0)
bc_v_periodic = dde.icbc.PeriodicBC(geom, 0, boundary_outlet, component=1)

# Pressure: fix at one point to remove null space
def fix_pressure(x):
    return 0.0
bc_p = dde.icbc.PointSetBC(np.array([[L/2, H/2]]), np.array([0.0]), component=2)

# Alternative: soft pressure gradient via PDE residual (often more stable)
# We already added dpdx as source term, so no extra BC needed for pressure

# -------------------------- Data and Model --------------------------
data = dde.data.PDE(
    geom,
    pde,
    [bc_u_bottom, bc_v_bottom, bc_u_top, bc_v_top,
     bc_u_periodic, bc_v_periodic, bc_p],
    num_domain=5000,
    num_boundary=1000,
    num_test=2000,
)

net = dde.nn.FNN([2] + [50] * 6 + [3], "tanh", "Glorot uniform")
model = dde.Model(data, net)

# -------------------------- Training --------------------------
dde.optimizers.config.set_LBFGS_options(maxcor=50, ftol=1e-12, gtol=1e-12, maxiter=50000)
model.compile("adam", lr=1e-3)
model.train(iterations=20000)

model.compile("L-BFGS")
losshistory, train_state = model.train()

# -------------------------- Prediction and Visualization --------------------------
x = np.linspace(0, L, 200)
y = np.linspace(0, H, 100)
X, Y = np.meshgrid(x, y)
XY = np.vstack((X.flatten(), Y.flatten())).T

output = model.predict(XY)
u_pred = output[:, 0].reshape(Y.shape)
v_pred = output[:, 1].reshape(Y.shape)
p_pred = output[:, 2].reshape(Y.shape)

# Analytical centerline velocity
u_center_analytical = u_analytical(H/2)
print(f"Max analytical velocity (centerline): {u_center_analytical:.6f}")
print(f"Max predicted velocity (centerline): {u_pred.max():.6f}")

# -------------------------- Plotting --------------------------
plt.style.use('default')
fig = plt.figure(figsize=(16, 8))

# Velocity magnitude
ax1 = plt.subplot(2, 3, 1)
im1 = ax1.contourf(X, Y, np.sqrt(u_pred**2 + v_pred**2), levels=50, cmap='turbo')
ax1.set_title('Velocity Magnitude |u|')
ax1.set_xlabel('x')
ax1.set_ylabel('y')
divider = make_axes_locatable(ax1)
cax = divider.append_axes("right", size="5%", pad=0.1)
plt.colorbar(im1, cax=cax)

# U velocity
ax2 = plt.subplot(2, 3, 2)
im2 = ax2.contourf(X, Y, u_pred, levels=50, cmap='RdBu_r')
ax2.set_title('U velocity')
ax2.set_xlabel('x')
ax2.set_ylabel('y')
divider = make_axes_locatable(ax2)
cax = divider.append_axes("right", size="5%", pad=0.1)
plt.colorbar(im2, cax=cax)

# V velocity (should be near zero)
ax3 = plt.subplot(2, 3, 3)
im3 = ax3.contourf(X, Y, v_pred, levels=50, cmap='RdBu_r')
ax3.set_title('V velocity (â‰ˆ0)')
ax3.set_xlabel('x')
ax3.set_ylabel('y')
divider = make_axes_locatable(ax3)
cax = divider.append_axes("right", size="5%", pad=0.1)
plt.colorbar(im3, cax=cax)

# Pressure
ax4 = plt.subplot(2, 3, 4)
im4 = ax4.contourf(X, Y, p_pred, levels=50, cmap='viridis')
ax4.set_title('Pressure')
ax4.set_xlabel('x')
ax4.set_ylabel('y')
divider = make_axes_locatable(ax4)
cax = divider.append_axes("right", size="5%", pad=0.1)
plt.colorbar(im4, cax=cax)

# Streamlines
ax5 = plt.subplot(2, 3, 5)
ax5.contourf(X, Y, u_pred, levels=50, cmap='turbo', alpha=0.8)
ax5.streamplot(X, Y, u_pred, v_pred, density=2, color='white', linewidth=1, arrowsize=1)
ax5.set_title('Velocity field + Streamlines')
ax5.set_xlabel('x')
ax5.set_ylabel('y')

# Profile comparison at x = L/2
ax6 = plt.subplot(2, 3, 6)
y_line = np.linspace(0, H, 100)
x_mid = L / 2
XY_mid = np.vstack((np.full_like(y_line, x_mid), y_line)).T
pred_mid = model.predict(XY_mid)
u_mid_pred = pred_mid[:, 0]
u_mid_analytical = u_analytical(y_line)

ax6.plot(u_mid_pred, y_line, 'r-', lw=2, label='PINN prediction')
ax6.plot(u_mid_analytical, y_line, 'k--', lw=2, label='Analytical Poiseuille')
ax6.set_xlabel('u velocity')
ax6.set_ylabel('y')
ax6.set_title('Velocity profile at x = L/2')
ax6.legend()
ax6.grid(True)

plt.tight_layout()
plt.show()

# Save loss history
dde.saveplot(losshistory, train_state, issave=True, isplot=True)